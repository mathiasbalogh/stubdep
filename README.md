# StubDep: The Stubbing Dependency Library

**StubDep** is a lightweight and intuitive Java library designed to simplify the creation of test data for unit and integration testing. It is especially useful for creating variations of objects with overridden or nullified fields, making your tests more expressive and concise. The library provides a clean API with three methods to handle all your stubbing needs.

---

## Why StubDep?
- **Ease of Use**: Create default objects with just one line of code.
- **Flexible Overrides**: Override any property values easily.
- **Nullification**: Create object or variants with specific fields nullified to test edge cases.
- **Type-Safe**: Generics ensure type safety for your stubs.

---

## Installation
Publishing to Maven Central coming soon. Once it is published you'll be able to use the steps below to add stubdep into your project.

### Gradle
```kotlin
dependencies {
    testImplementation("org.stub.dep:stubdep:0.0.1")
}
```
### Maven
```xml
<dependency>
    <groupId>org.stub.dep</groupId>
    <artifactId>stubdep</artifactId>
    <version>0.0.1</version>
    <scope>test</scope>
</dependency>
```
___
## API
### stub()
Create a new instance of a class with default values, optionally overriding specific properties

```java
Foo foo = StubDep.stub(Foo.class);
Baz baz = StubDep.stub(Baz.class, "property", "overridden value");
```
Parameters:
- clazz: The class to stub
- overrideKeyValues: Key-value pairs to override default values
  - Keys need to be a String of the field name being overridden
  - Values must be an instantiation of the class of the field being overridden, though they are nullable.

### stubVariant()
Create a variation of an existing object with overridden properties

```java
Foo foo = StubDep.stub(Foo.class);
Foo variant = StubDep.stubVariant(foo, "baz", new Baz());
```
Parameters:
- original: The original object to create a variation of
- overrideKeyValues: Key-value pairs to override the original object's values
  - Keys need to be a String of the field name being overridden
  - Values must be an instantiation of the class of the field being overridden, though they are nullable.

### stubVariantWithNullValues()
Create a variation of an existing object with specific fields set to `null`

```java
Foo foo = StubDep.stub(Foo.class);
Foo variant = StubDep.stubVariantWithNullValues(foo, "property", "baz");
```

Parameters:
- original: The original object to create a variation of
- fieldsToNullify: Field names to nullify
___
## Key Features
### Default Properties
StubDep generates default values for all fields in a class using its internal mappings for primitives, strings, dates, collections, and more.

This saves you time when writing tests and eliminates a lot of boilerplate code to stub out test data.

### Annotation-Aware Stubbing
Random values generated by StubDep will take field-level annotations into consideration.
For example:
```java
public record Foo(
        @Min(value = 1)
        @Max(value = 10)
        private Integer integer
) {}

@Test
public void test() {
    var classUnderTest = StubDep.stub(Foo.class);
    
    assert classUnderTest.integer() >= 1;
    assert classUnderTest.integer() <= 10;
}
```
StubDep supports annotation-aware stubbing for:
- String
- Numeric types
- Instant
- Date

Annotation-aware stubbing coming soon for:
- Collections

#### @NotNull
On all annotation aware stubbed fields, @NotNull annotation is not considered. This is a choice made because the purpose of the library is to stub data, so if the library has a generator for a type, the value should always be non-null.

### Overrides
Use key-value pairs to override specific fields for testing scenarios.

Keys need to be a String of the field name being overridden

Values are nullable (see below), but if they are not null they must be an instantiation of the class of the field being overridden.

### Nullification
Explicitly set fields to null to simulate missing or invalid data.

Of course this is possible with [stubVariantWithNullValues()](#stubvariantwithnullvalues).

It is also possible with our other API methods: 
```java
Foo foo = StubDep.stub(Foo.class, "property", null);
Foo fooz = StubDep.stubVariant(foo, "baz", null);
```
___
## Foreign Key Conundrum
There is an issue when stubbing classes annotated with Foreign key relationships.
Perhaps you see where this is going... 
When annotating a class with a foreign key relationship there is a circular dependency that results in a StackOverflowException as nested classes generate forever.

For now, the solution is that if any of the following annotations are present on a field, the stubbed instance will have a `null value` for that field.
- @ManyToOne
- @ManyToMany
- @OneToOne
- @OneToMany

There are plans to tackle this issue in the future in a more intelligent way
___
## Configuration
Currently, there is no support for configuring this library to behave differently.

But there are plans for future enhancements!

### Identifying custom POJOs
If a property is a custom POJO and not a standard type, StubDep can call the `stub()` method to generate the test data.

But how does it know? Currently, it looks at the package of a class and if the package begins with `org.stub.dep` it will call the `stub()` method instead of looking for a `RandomDataGenerator` implementation to use.

In the future, this list of custom POJO package classes should be configurable to be additive to the current defaults.

### Creating custom RandomDataGenerator implementations
In the future, it would be useful for a user of StubDep to be able to write their own custom implementation of a RandomDataGenerator that StubDep would detect and use.
___
## Contributing
Contributions are welcome! If you need a data-type supported, have ideas for new features or encounter issues,
feel free to open an issue or submit a pull request [here](https://github.com/mathiasbalogh/stubdep).
